% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/traybake.R
\name{traybake}
\alias{traybake}
\title{Derive radially constrained spatial subsamples from occurrence data}
\usage{
traybake(
  dat,
  xy,
  uniqID = "cell",
  r,
  standardiseCells = T,
  exhaustClusters = F,
  nSite = 3,
  nCookie = 100,
  nBatch = 100,
  crs = "EPSG:8857",
  output = "full",
  n.cores = 1
)
}
\arguments{
\item{dat}{A data.frame or matrix containing taxon names, Cartesian coordinates, and any associated variables.}

\item{xy}{A vector of two elements, specifying the name of columns in \code{dat} containing Cartesian coordinates, e.g. longitude and latitude. Coordinates for any shared sampling sites should be identical, and where sites are raster cells, coordinates are usually expected to be cell centroids.}

\item{uniqID}{A character string specifying the name of the column in \code{dat} containing unique site identifiers (e.g., cell numbers added via \code{\link[=rasterOccData]{rasterOccData()}}). Default is \code{"cell"}.}

\item{r}{A numeric value specifying the radius (in metres) to use to define radially constrained regions.}

\item{standardiseCells}{Either \code{TRUE} (the default) or \code{FALSE}. If \code{TRUE}, \code{nCookie} samples containing \code{nSite} grid cells are drawn from each radially constrained region and returned. If \code{FALSE}, the raw radially constrained regions are returned.}

\item{exhaustClusters}{Either \code{TRUE} or \code{FALSE} (the default). See below for explanation.}

\item{nSite}{A numeric value specifying the minimum number of unique populated sites that must fall within a radially constrained region for it to be considered viable. Also, specifies the number of sites that are randomly drawn \emph{without} replacement from each radially constrained region if \code{standardiseCells = TRUE}. Default is \code{3}.}

\item{nCookie}{A numeric value specifying the number of subsamples of grid cells to be drawn from each radially constrained region if \code{standardiseCells = TRUE}. Default is \code{100}.}

\item{nBatch}{A numeric value specifying the number of subsamples of radially constrained regions to be drawn from the clusters identified. Default is \code{100}.}

\item{crs}{A character string specifying a coordinate reference system (CRS). You can use the following formats to define coordinate reference systems: WKT, PROJ.4 (e.g., \code{crs = +proj=longlat +datum=WGS84}), or an EPSG code (e.g., \code{crs = "EPSG:4326"}). But note that the PROJ.4 notation has been deprecated, and you can only use it with the WGS84/NAD83 and NAD27 datums. Other datums are silently ignored. Default is \code{"EPSG:8857"}.}

\item{output}{A character string, either \code{"full"} or \code{"seeds"}. Specifies whether the returned data should be the subset of rows from dat associated with those coordinates (\code{output = "full"}) or a data.frame of the seeds used (\code{output = "seeds"}).}

\item{n.cores}{A numeric value specifying the number of cores to used. Note, this parallelisation method relies on forking, and so \code{n.cores} must equal \code{1} on Windows.}
}
\value{
Output format changes depending on arguments used.
\itemize{
\item \code{standardiseCells = FALSE}: a list of length \emph{n}, where \emph{n} is the number of clusters identified as viable. Each element of this list is a list of length \emph{c}, where \emph{c} is the number of radially constrained regions identified as viable within each cluster. Each element of these nested lists is a data.frame or matrix (matching the class of \code{dat}) containing \emph{k} rows, where \emph{k} is the number of occurrences within dat that fall within a specific radially constrained region.
\item \code{standardiseCells = TRUE}: a list of length \emph{n}, where \emph{n} is the number of radially constrained regions sampled. If \code{exhaustClusters = TRUE}, then clusters may be represented by more than one radially constrained regions. Otherwise, each cluster will be represented by a single radially constrained region. Each element of this list is a list of length \code{nCookie}, each element of which is a data.frame or matrix (matching the class of dat) containing all occurrences associated with the \code{nSite} grid cells sampled \emph{without replacement} from the radially constrained region.
If \code{output = 'full'}, all \code{dat} columns are returned for the rows associated with the radially constrained region/subsample. If \code{output = 'seeds'}, only the coordinates of the viable seeds are returned.
}
}
\description{
This function is a modified version of \code{\link[divvy:cookies]{divvy::cookies()}}.

In brief, the function takes a single location as a starting (seed) point, circumscribes a circular buffer of \code{r} metres around it, and then identifies which observations fall within this circle. This process is repeated for each unique site in the dataset (unless these seed points are manually specified). The radially constrained regions (RCRs) that result are then assessed against user-specified criteria; if they contain insufficient data (measured by the number of unique populated sites they contain), they are dropped from the analysis. These RCRs are then grouped into spatially distinct clusters; RCRs within clusters may overlap by a cell or more but each cluster is distinct. The RCRs are then either returned in full (i.e., all occurrences that fall within them are returned) or subsampled.

\strong{Differences between this function and divvy's cookies:}
\enumerate{
\item Grouping of overlapping RCRs into clusters which are themselves subsampled
This extra layer of iteration was added so as to give users the ability to eliminate pseudoreplication of spatial regions, and therefore standardise the sampling of different geographic areas, without dropping heaps of occurrence of data from the analysis. The latter is useful when the function is applied to global fossil occurrence datasets, as it curbs the impact of some geographic areas having an order of magnitude more occurrence data associated with them than others (e.g., the oversampling of Western European and North American localities relative to other parts of the world). Overlap is defined as the sharing of 1 or more grid cells between radially constrained regions. Note, some radially constrained regions within clusters do not overlap but are bridged by one or more RCRs that collectively share at least 1 grid cell with each non-overlapping RCR. If \code{standardiseCells = TRUE} and \code{exhaustClusters = TRUE}, multiple non-overlapping RCRs may be selected to represent a cluster within a single subsample.
\item Subsampling of \code{nSite} grid cells of each radially constrained region \code{nCookie} times.
This functions takes a different approach to subsampling radially constrained regions than \code{\link[divvy:cookies]{divvy::cookies()}}. It differs in that it draws the \code{nCookie} subsamples from each viable RCR, rather than randomly drawing \code{nCookie} subsamples from \code{nCookie} randomly selected viable RCRs. In conjunction with the clustering approach implemented, this guarantees that no grid cell will be sampled twice in a subsample, which is a possibility when \code{\link[divvy:cookies]{divvy::cookies()}} is applied to occurrence data with high density clusters of points.
}
}
\examples{
# Two examples, first with non-rasterised data
# Generate occurrence data
n <- 100
set.seed(5)

# 100 sets of x and y coordinates
x <- runif(n, 0, 100)
y <- runif(n, 0, 100)

# Give each site a unique identifier
z <- seq(1, n, 1)

# Combine into data frame and label columns
pts <- data.frame(x, y, z)
colnames(pts) <- c("x", "y", "z")

# Derive subsamples, 10km radius regions
# Minimum 3 sites, no overlap
subsamples <- traybake(dat = pts, xy = c("x", "y"),
uniqID = "z", r = 25, standardiseCells = TRUE,
exhaustClusters = TRUE, nSite = 3,
nCookie = 100, nBatch = 100)
}
